{% set indent = "    " %}{% set current_indent = indent * (indent_level if indent_level is defined else 0) %}
{{ current_indent }}#[allow(dead_code)]
{{ current_indent }}#[allow(non_camel_case_types)]
{{ current_indent }}#[derive(Serialize, Deserialize)]
{{ current_indent }}#[derive(Clone, Debug)]
{{ current_indent }}pub enum {{ enum_name }} {
{% for variant in variants %}{{ current_indent }}    {{ variant }},{% if not loop.last %}{{ '\n' }}{% endif %}{% endfor %}
{{ current_indent }}}

{{ current_indent }}#[derive(Debug, PartialEq, Eq)]
{{ current_indent }}pub struct {{ enum_name }}Error;

{{ current_indent }}impl std::str::FromStr for {{ enum_name }} {
{{ current_indent }}    type Err = {{ enum_name }}Error;
{{ current_indent }}    fn from_str(value: &str) -> Result<Self, Self::Err> {
{{ current_indent }}        match value {
{% for variant in variants %}{{ current_indent }}            "{{ variant }}" => Ok({{ enum_name }}::{{ variant }}),{% if not loop.last %}{{ '\n' }}{% endif %}{% endfor %}
{{ current_indent }}            _ => Err({{ enum_name }}Error),
{{ current_indent }}        }
{{ current_indent }}    }
{{ current_indent }}}

{{ current_indent }}impl std::fmt::Display for {{ enum_name }} {
{{ current_indent }}    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
{{ current_indent }}        let enum_str = match self {
{% for variant in variants %}{{ current_indent }}            {{ current_indent }}{{ enum_name }}::{{ variant }} => "{{ variant }}",{% if not loop.last %}{{ '\n' }}{% endif %}{% endfor %}
{{ current_indent }}        };
{{ current_indent }}        write!(f, "{enum_str}")
{{ current_indent }}    }
{{ current_indent }}}
